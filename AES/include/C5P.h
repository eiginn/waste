/*
 Copyright (c) 1998-2003 VIA Technologies, Inc.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTIES OR REPRESENTATIONS; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
*/

/*
 *  This file provides the cipher & rand number interfaces which are supported 
 *  by C5P CPU.
 *  Author: Raymond Cai
 *  Date Created: 2003.12.1
*/
#ifndef _C5P_H_
#define _C5P_H_

//Get size_t
#include <stddef.h>

#define VIA_C5P		/* define when AES is supported by VIA C5P CPU  */

#ifdef __cplusplus
extern "C" {
#endif

typedef int	BOOL;
#ifndef true
#define true 1
#endif

#ifndef false
#define false 0
#endif

typedef enum _RNG_Result
{
	e_RNG_Successed,
	e_RNG_Failed
}RNG_Result;


/*
 *	Function : To test whether the hardware can generate random number
 *	Input	 :
 *  Output   :
 *	return   : true --- 1 :if it can be generated by hardware
 *	           false -- 0 : Cann't
 */
BOOL c5p_rng_available();

/*
 *	Function : To generate random number by hardware
 *	Input	 : bufl : how many bytes random number need be generate
 *			   *buf : the pointer where the rand number will be stored		  
 *  Output   : 	
 *	return   : e_RNG_Successed : successed
 *	           e_RNG_Failed : error.
 */
RNG_Result c5p_rng_rand(int bufl, unsigned char *buf);

typedef enum _AES_Result{
	e_AES_Successed,
	e_AES_Failed,
	e_AES_Addr_Not_Aligned, //for hardware the block is needed aligned by 128bits
	e_AES_Not_Block,        //the plaintxt must be N * 128bits
	e_AES_Not_Key,			//Key len = 128, 192, 256 (bits) or 16, 24, 32 (bytes)
	e_AES_Mode_Not_Support
}
AES_Result;

typedef enum _AES_MODE
{
	e_aes_ecb,
	e_aes_cbc,
	e_aes_cfb,
	e_aes_ofb
}AES_MODE;

/*
 *	Function : To test whether the hardware has function of AES de/encrytion
 *	Input	 :
 *  Output   :
 *	return   : true --- 1 : if it has
 *	           false -- 0 : Cann't
 */
BOOL c5p_aes_available();

/*
 *	Function : To encrypt plaintxt to cipertxt by hardware
 *	Input	 : *key		: point to the address of the key
 *				klen	: length of the key(128,192,156 bits) or (16, 24, 32 bytes)
 *				mode	: only the value of AES_MODE is permitted.
 *				plaintxt: point to the address of plain text will be encrypted
 *				plainlen: the length of the plaintxt (in bytes)
 *				cipertxt: pointer where the ciphertxt will be stored
 *				IV		: Initiliaze vector. the content in this address will be changed
 *  Output   : 	cipertxt: pointer where the ciphertxt will be stored
 *	return   : e_AES_Successed : successed
 *	           e_AES_Addr_Not_Aligned : Address isn't aligned by 128bits.
 *	Note	 : all address must be aligned by 128bits, 
 *				if IV isn't needed, please use NULL instead of IV.
 */
AES_Result c5p_aes_encrypt(int *key, int klen, AES_MODE mode, 
						   int *plaintxt, int plainlen, int *cipertxt, int *IV);

/*
 *	Function : To decrypt cipertxt to plaintxt by hardware
 *	Input	 : *key		: point to the address of the key
 *				klen	: length of the key(128,192,156 bits) or (16, 24, 32 bytes)
 *				mode	: only the value of AES_MODE is permitted.
 *				cipertxt: point to the address of cipher text will be decrypted
 *				ciperlen: the length of the cipertxt (in bytes)
 *				plaintxt: pointer where the plaintxt will be stored
 *				IV		: Initiliaze vector. the content in this address will be changed
 *  Output   : 	plaintxt: pointer where the ciphertxt will be stored
 *	return   : e_AES_Successed : successed
 *	           e_AES_Addr_Not_Aligned : Address isn't aligned by 128bits.
 *	Note	 : all address must be aligned by 128bits, 
 *				if IV isn't needed, please use NULL instead of IV.
 */
AES_Result c5p_aes_decrypt(int *key, int klen,
					 AES_MODE mode, int *cipertxt, int ciperlen, int *plaintxt, int *IV);


/* 
 * to allocate size bytes memory which is aligned by 128bits,
 *	if you uses this function to alloc memory,
 * you must use c5p_free to free the memory.
 * Note: 
 */
void *c5p_malloc(size_t size);

void c5p_free(void *p);


/*
 *	The following part is to implement software ase en/decrypt.
 *  all function is started with the prefix "sft"
 */

/*
 *	Function : To encrypt plaintxt to cipertxt by software
 *	Input	 : *key		: point to the address of the key
 *				klen	: length of the key(128,192,156 bits) or (16, 24, 32 bytes)
 *				mode	: only the value of AES_MODE is permitted.
 *				plaintxt: point to the address of plain text will be encrypted
 *				plainlen: the length of the plaintxt (in bytes)
 *				cipertxt: pointer where the ciphertxt will be stored
 *				IV		: Initiliaze vector. the content in this address will be changed
 *  Output   : 	cipertxt: pointer where the ciphertxt will be stored
 *	return   : e_AES_Successed : successed
 *	           e_AES_Addr_Not_Aligned : Address isn't aligned by 128bits.
 *	Note	 : the plaintxt and cipertxt can use the same address
 */
AES_Result sft_aes_encrypt(int *key, int klen, AES_MODE mode, 
						   int *plaintxt, int plainlen, int *cipertxt, int *IV);
/*
 *	Function : To decrypt cipertxt to plaintxt by software
 *	Input	 : *key		: point to the address of the key
 *				klen	: length of the key(128,192,156 bits) or (16, 24, 32 bytes)
 *				mode	: only the value of AES_MODE is permitted.
 *				cipertxt: point to the address of cipher text will be decrypted
 *				ciperlen: the length of the cipertxt (in bytes)
 *				plaintxt: pointer where the plaintxt will be stored
 *				IV		: Initiliaze vector. the content in this address will be changed
 *  Output   : 	plaintxt: pointer where the ciphertxt will be stored
 *	return   : e_AES_Successed : successed
 *	           e_AES_Addr_Not_Aligned : Address isn't aligned by 128bits.
 *	Note	 : the plaintxt and cipertxt can use the same address
 */
AES_Result sft_aes_decrypt(int *key, int klen,
					 AES_MODE mode, int *cipertxt, int ciperlen, int *plaintxt, int *IV);

#ifdef __cplusplus
}
#endif

#endif /* _C5P_H_ */
